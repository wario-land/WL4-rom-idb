#Auto-generate the patch file which can be used in WL4Editor
#@author shinespeciall

# changelog: 
# v0.1: The whole logic is ported from the Ghidra script version of WL4FuncExporter.py
#       auto generate the comments and the #define lines for functions and global variables used in the function_address (see the main function).
#       Then save the result as a C file on the Desktop path.
#       The feature is still crappy but barely works.

import ida_allins
import ida_auto
import ida_bytes
import ida_diskio
import ida_enum
import ida_fpro
import ida_frame
import ida_funcs
import ida_ida
import ida_idaapi
import ida_idp
import ida_hexrays
import ida_kernwin
import ida_lines
import ida_loader
import ida_moves
import ida_nalt
import ida_name
import ida_netnode
import ida_pro
import ida_segment
import ida_segregs
import ida_struct
import ida_typeinf
import ida_ua
import ida_xref
import idautils
import idc
import os

TARGET_FUNC_ENTRY_ADDR_VALUE = 0

# parse symbols from symbol addresses
symbol_define_str_list = []
function_define_str_list = []


def get_symbol_info(ea):
    var_type_str = "unsigned int"
    if idc.get_item_size(ea) == 1:
        var_type_str = "unsigned char"
    elif idc.get_item_size(ea) == 2:
        var_type_str = "unsigned short"

    var_signature = "#define " + idc.get_name(ea) + " (*( volatile " + var_type_str + "*) " + hex(ea + 1) + ")"
    return var_signature

def print_used_global_vars(func_ea):
    f = ida_funcs.get_func(func_ea)
    exist_global_vars = []
    global_vars_signature = ""

    # Not all the global vars can be found using this logic
    for ea in list(range(f.start_ea, f.end_ea, 4)):
        target = idaapi.get_dword(ea)
        if target >= 0x2000000 and target < 0x8000000:
            if target not in exist_global_vars:
                exist_global_vars.append(target)
                symbolname = idc.get_name(target)
                if len(symbolname) > 0:
                    result_str = get_symbol_info(target)
                    symbol_define_str_list.append(result_str)

                    # test code
                    # print(result_str)
    
    return global_vars_signature


def is_function_call(ea):
    # Get the mnemonic of the instruction at the given address
    mnemonic = idc.print_insn_mnem(ea)
    
    # Check if the mnemonic indicates a function call
    if mnemonic.startswith("BL"):
        # Check if there's exactly one operand
        if idc.get_operand_type(ea, 0) == idc.o_near:
            return True
    
    return False

def get_function_info(ea):

    func_name = idc.get_func_name(ea)
    func_type_str = idc.get_type(ea)

    if func_type_str is None:
        # If no type information is available, then it is the IDA pro's problem, we need to manually fix it
        func_signature = "#define " + func_name + " (( void" + " (*) " + ") " + hex(ea | 1) + ")" + " // -------------------------------- TODO: Fix manually"
    else:
        return_type_str = func_type_str.split(" ")[0]
        params_str = func_type_str[func_type_str.find("(")+1:func_type_str.find(")")]
        func_signature = "#define " + func_name + " ((" + return_type_str + " (*) " + params_str + ") " + hex(ea | 1) + ")"

    return func_signature

def print_function_calls(func_ea):
    f = ida_funcs.get_func(func_ea)
    exist_funcs = []
    for ea in Heads(f.start_ea, f.end_ea):
        insn = idaapi.insn_t()
        length = idaapi.decode_insn(insn, ea) # don't delete this line

        # search for call instructions
        if ida_idp.is_call_insn(insn) and is_function_call(ea):
            target = idc.get_operand_value(ea, 0)
            if target not in exist_funcs:
                exist_funcs.append(target)
                # print(f"Function call found at 0x{ea:X} to function at 0x{target:X}")
                result_str = get_function_info(target)
                result_str.replace("__int16", "short")
                function_define_str_list.append(result_str)

                # test code
                # print(result_str)

def write_to_file(function_name, function_ea):

    final_str = ""
    final_str += "// @Description a function wrapper patch for " + function_name + " generated by IDA pro script: WL4FuncExporter.py\n"
    modified_function_entry_addr_str = hex(function_ea)
    final_str += "// function starts at: " + modified_function_entry_addr_str + "\n\n"
    final_str += "// @HookAddress [HookAddr]\n\n"

    final_str += "/** starts from [HookAddr], no alignment byte needed\n"
    final_str += " *  ends at [JumpBackAddr] with a branch instruction to jump out\n"
    final_str += " * .thumb\n"
    final_str += "    ldr r0, .DATA\n"
    final_str += "    mov lr, r0\n"
    final_str += "    ldr r0, .DATA + 4\n"
    final_str += "    bx r0\n"
    final_str += " * .DATA:\n"
    final_str += "    .word 0x0801B929\n"
    final_str += "    .word 0xAAAAAAAA\n"
    final_str += " *\n"
    final_str += " * Hook String generated by gcc: 01488646 01480047 29b90108 aaaaaaaa\n"
    final_str += " */\n"
    final_str += "// @HookString [fill this manually]\n\n"

    for entry in symbol_define_str_list:
        final_str += entry + "\n"
    final_str += "\n"
    for entry in function_define_str_list:
        final_str += entry + "\n"

    final_str += "\n\n"
    final_str += "// [Copy the C Code from IDA pro for now.]\n"
    # final_str += C_Code_string
    final_str += "\n"

    # Get the current user's home directory
    home_dir = os.path.expanduser('~')

    # Construct the path to the desktop
    desktop_path = os.path.join(home_dir, 'Desktop')

    # Specify the file name
    file_name = 'test.c'

    # Full path to the file
    file_path = os.path.join(desktop_path, file_name)

    # automatically closes the file after the block of code inside it executes
    with open(file_path, "w") as f:
        f.write(final_str)


def main():
    function_address = 0x801F628
    funct_name = idc.get_func_name(function_address)

    symbol_define_str_list.clear()
    function_define_str_list.clear()

    print_used_global_vars(function_address)
    print_function_calls(function_address)

    write_to_file(funct_name, function_address)

    print("script execution complete.")

if __name__ == "__main__":
    main()